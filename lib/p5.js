var __defProp = Object.defineProperty;
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// src/core/constants.js
var exports_constants = {};
__export(exports_constants, {
  _DEFAULT_TEXT_FILL: () => {
    {
      return _DEFAULT_TEXT_FILL;
    }
  },
  _DEFAULT_STROKE: () => {
    {
      return _DEFAULT_STROKE;
    }
  },
  _DEFAULT_LEADMULT: () => {
    {
      return _DEFAULT_LEADMULT;
    }
  },
  _DEFAULT_FILL: () => {
    {
      return _DEFAULT_FILL;
    }
  },
  _CTX_MIDDLE: () => {
    {
      return _CTX_MIDDLE;
    }
  },
  WORD: () => {
    {
      return WORD;
    }
  },
  WEBGL2: () => {
    {
      return WEBGL2;
    }
  },
  WEBGL: () => {
    {
      return WEBGL;
    }
  },
  WAIT: () => {
    {
      return WAIT;
    }
  },
  VERSION: () => {
    {
      return VERSION;
    }
  },
  UP_ARROW: () => {
    {
      return UP_ARROW;
    }
  },
  UNSIGNED_INT: () => {
    {
      return UNSIGNED_INT;
    }
  },
  UNSIGNED_BYTE: () => {
    {
      return UNSIGNED_BYTE;
    }
  },
  TWO_PI: () => {
    {
      return TWO_PI;
    }
  },
  TRIANGLE_STRIP: () => {
    {
      return TRIANGLE_STRIP;
    }
  },
  TRIANGLE_FAN: () => {
    {
      return TRIANGLE_FAN;
    }
  },
  TRIANGLES: () => {
    {
      return TRIANGLES;
    }
  },
  TOP: () => {
    {
      return TOP;
    }
  },
  THRESHOLD: () => {
    {
      return THRESHOLD;
    }
  },
  TEXTURE: () => {
    {
      return TEXTURE;
    }
  },
  TEXT: () => {
    {
      return TEXT;
    }
  },
  TESS: () => {
    {
      return TESS;
    }
  },
  TAU: () => {
    {
      return TAU;
    }
  },
  TAB: () => {
    {
      return TAB;
    }
  },
  SUBTRACT: () => {
    {
      return SUBTRACT;
    }
  },
  STROKE: () => {
    {
      return STROKE;
    }
  },
  SQUARE: () => {
    {
      return SQUARE;
    }
  },
  SOFT_LIGHT: () => {
    {
      return SOFT_LIGHT;
    }
  },
  SMOOTH: () => {
    {
      return SMOOTH;
    }
  },
  SHIFT: () => {
    {
      return SHIFT;
    }
  },
  SCREEN: () => {
    {
      return SCREEN;
    }
  },
  ROUND: () => {
    {
      return ROUND;
    }
  },
  RIGHT_ARROW: () => {
    {
      return RIGHT_ARROW;
    }
  },
  RIGHT: () => {
    {
      return RIGHT;
    }
  },
  RGBA: () => {
    {
      return RGBA;
    }
  },
  RGB: () => {
    {
      return RGB;
    }
  },
  RETURN: () => {
    {
      return RETURN;
    }
  },
  REPLACE: () => {
    {
      return REPLACE;
    }
  },
  REPEAT: () => {
    {
      return REPEAT;
    }
  },
  REMOVE: () => {
    {
      return REMOVE;
    }
  },
  RAD_TO_DEG: () => {
    {
      return RAD_TO_DEG;
    }
  },
  RADIUS: () => {
    {
      return RADIUS;
    }
  },
  RADIANS: () => {
    {
      return RADIANS;
    }
  },
  QUARTER_PI: () => {
    {
      return QUARTER_PI;
    }
  },
  QUAD_STRIP: () => {
    {
      return QUAD_STRIP;
    }
  },
  QUADS: () => {
    {
      return QUADS;
    }
  },
  QUADRATIC: () => {
    {
      return QUADRATIC;
    }
  },
  PROJECT: () => {
    {
      return PROJECT;
    }
  },
  POSTERIZE: () => {
    {
      return POSTERIZE;
    }
  },
  PORTRAIT: () => {
    {
      return PORTRAIT;
    }
  },
  POINTS: () => {
    {
      return POINTS;
    }
  },
  PIE: () => {
    {
      return PIE;
    }
  },
  PI: () => {
    {
      return PI;
    }
  },
  P2D: () => {
    {
      return P2D;
    }
  },
  OVERLAY: () => {
    {
      return OVERLAY;
    }
  },
  OPTION: () => {
    {
      return OPTION;
    }
  },
  OPEN: () => {
    {
      return OPEN;
    }
  },
  OPAQUE: () => {
    {
      return OPAQUE;
    }
  },
  NORMAL: () => {
    {
      return NORMAL;
    }
  },
  NEAREST: () => {
    {
      return NEAREST;
    }
  },
  MULTIPLY: () => {
    {
      return MULTIPLY;
    }
  },
  MOVE: () => {
    {
      return MOVE;
    }
  },
  MITER: () => {
    {
      return MITER;
    }
  },
  MIRROR: () => {
    {
      return MIRROR;
    }
  },
  LINE_STRIP: () => {
    {
      return LINE_STRIP;
    }
  },
  LINE_LOOP: () => {
    {
      return LINE_LOOP;
    }
  },
  LINES: () => {
    {
      return LINES;
    }
  },
  LINEAR: () => {
    {
      return LINEAR;
    }
  },
  LIGHTEST: () => {
    {
      return LIGHTEST;
    }
  },
  LEFT_ARROW: () => {
    {
      return LEFT_ARROW;
    }
  },
  LEFT: () => {
    {
      return LEFT;
    }
  },
  LANDSCAPE: () => {
    {
      return LANDSCAPE;
    }
  },
  LABEL: () => {
    {
      return LABEL;
    }
  },
  ITALIC: () => {
    {
      return ITALIC;
    }
  },
  INVERT: () => {
    {
      return INVERT;
    }
  },
  IMMEDIATE: () => {
    {
      return IMMEDIATE;
    }
  },
  IMAGE: () => {
    {
      return IMAGE;
    }
  },
  HSL: () => {
    {
      return HSL;
    }
  },
  HSB: () => {
    {
      return HSB;
    }
  },
  HARD_LIGHT: () => {
    {
      return HARD_LIGHT;
    }
  },
  HAND: () => {
    {
      return HAND;
    }
  },
  HALF_PI: () => {
    {
      return HALF_PI;
    }
  },
  HALF_FLOAT: () => {
    {
      return HALF_FLOAT;
    }
  },
  GRID: () => {
    {
      return GRID;
    }
  },
  GRAY: () => {
    {
      return GRAY;
    }
  },
  FLOAT: () => {
    {
      return FLOAT;
    }
  },
  FLAT: () => {
    {
      return FLAT;
    }
  },
  FILL: () => {
    {
      return FILL;
    }
  },
  FALLBACK: () => {
    {
      return FALLBACK;
    }
  },
  EXCLUSION: () => {
    {
      return EXCLUSION;
    }
  },
  ESCAPE: () => {
    {
      return ESCAPE;
    }
  },
  ERODE: () => {
    {
      return ERODE;
    }
  },
  ENTER: () => {
    {
      return ENTER;
    }
  },
  DOWN_ARROW: () => {
    {
      return DOWN_ARROW;
    }
  },
  DODGE: () => {
    {
      return DODGE;
    }
  },
  DILATE: () => {
    {
      return DILATE;
    }
  },
  DIFFERENCE: () => {
    {
      return DIFFERENCE;
    }
  },
  DELETE: () => {
    {
      return DELETE;
    }
  },
  DEG_TO_RAD: () => {
    {
      return DEG_TO_RAD;
    }
  },
  DEGREES: () => {
    {
      return DEGREES;
    }
  },
  DARKEST: () => {
    {
      return DARKEST;
    }
  },
  CURVE: () => {
    {
      return CURVE;
    }
  },
  CROSS: () => {
    {
      return CROSS;
    }
  },
  COVER: () => {
    {
      return COVER;
    }
  },
  CORNERS: () => {
    {
      return CORNERS;
    }
  },
  CORNER: () => {
    {
      return CORNER;
    }
  },
  CONTROL: () => {
    {
      return CONTROL;
    }
  },
  CONTAIN: () => {
    {
      return CONTAIN;
    }
  },
  CLOSE: () => {
    {
      return CLOSE;
    }
  },
  CLAMP: () => {
    {
      return CLAMP;
    }
  },
  CHORD: () => {
    {
      return CHORD;
    }
  },
  CHAR: () => {
    {
      return CHAR;
    }
  },
  CENTER: () => {
    {
      return CENTER;
    }
  },
  BURN: () => {
    {
      return BURN;
    }
  },
  BOTTOM: () => {
    {
      return BOTTOM;
    }
  },
  BOLDITALIC: () => {
    {
      return BOLDITALIC;
    }
  },
  BOLD: () => {
    {
      return BOLD;
    }
  },
  BLUR: () => {
    {
      return BLUR;
    }
  },
  BLEND: () => {
    {
      return BLEND;
    }
  },
  BEZIER: () => {
    {
      return BEZIER;
    }
  },
  BEVEL: () => {
    {
      return BEVEL;
    }
  },
  BASELINE: () => {
    {
      return BASELINE;
    }
  },
  BACKSPACE: () => {
    {
      return BACKSPACE;
    }
  },
  AXES: () => {
    {
      return AXES;
    }
  },
  AUTO: () => {
    {
      return AUTO;
    }
  },
  ARROW: () => {
    {
      return ARROW;
    }
  },
  ALT: () => {
    {
      return ALT;
    }
  },
  ADD: () => {
    {
      return ADD;
    }
  }
});
var _PI, VERSION, P2D, WEBGL, WEBGL2, ARROW, CROSS, HAND, MOVE, TEXT, WAIT, HALF_PI, PI, QUARTER_PI, TAU, TWO_PI, DEGREES, RADIANS, DEG_TO_RAD, RAD_TO_DEG, CORNER, CORNERS, RADIUS, RIGHT, LEFT, CENTER, TOP, BOTTOM, BASELINE, POINTS, LINES, LINE_STRIP, LINE_LOOP, TRIANGLES, TRIANGLE_FAN, TRIANGLE_STRIP, QUADS, QUAD_STRIP, TESS, CLOSE, OPEN, CHORD, PIE, PROJECT, SQUARE, ROUND, BEVEL, MITER, RGB, HSB, HSL, AUTO, ALT, BACKSPACE, CONTROL, DELETE, DOWN_ARROW, ENTER, ESCAPE, LEFT_ARROW, OPTION, RETURN, RIGHT_ARROW, SHIFT, TAB, UP_ARROW, BLEND, REMOVE, ADD, DARKEST, LIGHTEST, DIFFERENCE, SUBTRACT, EXCLUSION, MULTIPLY, SCREEN, REPLACE, OVERLAY, HARD_LIGHT, SOFT_LIGHT, DODGE, BURN, THRESHOLD, GRAY, OPAQUE, INVERT, POSTERIZE, DILATE, ERODE, BLUR, NORMAL, ITALIC, BOLD, BOLDITALIC, CHAR, WORD, _DEFAULT_TEXT_FILL, _DEFAULT_LEADMULT, _CTX_MIDDLE, LINEAR, QUADRATIC, BEZIER, CURVE, STROKE, FILL, TEXTURE, IMMEDIATE, IMAGE, NEAREST, REPEAT, CLAMP, MIRROR, FLAT, SMOOTH, LANDSCAPE, PORTRAIT, _DEFAULT_STROKE, _DEFAULT_FILL, GRID, AXES, LABEL, FALLBACK, CONTAIN, COVER, UNSIGNED_BYTE, UNSIGNED_INT, FLOAT, HALF_FLOAT, RGBA;
var init_constants = __esm(() => {
  _PI = Math.PI;
  VERSION = "VERSION_CONST_WILL_BE_REPLACED_BY_BROWSERIFY_BUILD_PROCESS";
  P2D = "p2d";
  WEBGL = "webgl";
  WEBGL2 = "webgl2";
  ARROW = "default";
  CROSS = "crosshair";
  HAND = "pointer";
  MOVE = "move";
  TEXT = "text";
  WAIT = "wait";
  HALF_PI = _PI / 2;
  PI = _PI;
  QUARTER_PI = _PI / 4;
  TAU = _PI * 2;
  TWO_PI = _PI * 2;
  DEGREES = "degrees";
  RADIANS = "radians";
  DEG_TO_RAD = _PI / 180;
  RAD_TO_DEG = 180 / _PI;
  CORNER = "corner";
  CORNERS = "corners";
  RADIUS = "radius";
  RIGHT = "right";
  LEFT = "left";
  CENTER = "center";
  TOP = "top";
  BOTTOM = "bottom";
  BASELINE = "alphabetic";
  POINTS = 0;
  LINES = 1;
  LINE_STRIP = 3;
  LINE_LOOP = 2;
  TRIANGLES = 4;
  TRIANGLE_FAN = 6;
  TRIANGLE_STRIP = 5;
  QUADS = "quads";
  QUAD_STRIP = "quad_strip";
  TESS = "tess";
  CLOSE = "close";
  OPEN = "open";
  CHORD = "chord";
  PIE = "pie";
  PROJECT = "square";
  SQUARE = "butt";
  ROUND = "round";
  BEVEL = "bevel";
  MITER = "miter";
  RGB = "rgb";
  HSB = "hsb";
  HSL = "hsl";
  AUTO = "auto";
  ALT = 18;
  BACKSPACE = 8;
  CONTROL = 17;
  DELETE = 46;
  DOWN_ARROW = 40;
  ENTER = 13;
  ESCAPE = 27;
  LEFT_ARROW = 37;
  OPTION = 18;
  RETURN = 13;
  RIGHT_ARROW = 39;
  SHIFT = 16;
  TAB = 9;
  UP_ARROW = 38;
  BLEND = "source-over";
  REMOVE = "destination-out";
  ADD = "lighter";
  DARKEST = "darken";
  LIGHTEST = "lighten";
  DIFFERENCE = "difference";
  SUBTRACT = "subtract";
  EXCLUSION = "exclusion";
  MULTIPLY = "multiply";
  SCREEN = "screen";
  REPLACE = "copy";
  OVERLAY = "overlay";
  HARD_LIGHT = "hard-light";
  SOFT_LIGHT = "soft-light";
  DODGE = "color-dodge";
  BURN = "color-burn";
  THRESHOLD = "threshold";
  GRAY = "gray";
  OPAQUE = "opaque";
  INVERT = "invert";
  POSTERIZE = "posterize";
  DILATE = "dilate";
  ERODE = "erode";
  BLUR = "blur";
  NORMAL = "normal";
  ITALIC = "italic";
  BOLD = "bold";
  BOLDITALIC = "bold italic";
  CHAR = "CHAR";
  WORD = "WORD";
  _DEFAULT_TEXT_FILL = "#000000";
  _DEFAULT_LEADMULT = 1.25;
  _CTX_MIDDLE = "middle";
  LINEAR = "linear";
  QUADRATIC = "quadratic";
  BEZIER = "bezier";
  CURVE = "curve";
  STROKE = "stroke";
  FILL = "fill";
  TEXTURE = "texture";
  IMMEDIATE = "immediate";
  IMAGE = "image";
  NEAREST = "nearest";
  REPEAT = "repeat";
  CLAMP = "clamp";
  MIRROR = "mirror";
  FLAT = "flat";
  SMOOTH = "smooth";
  LANDSCAPE = "landscape";
  PORTRAIT = "portrait";
  _DEFAULT_STROKE = "#000000";
  _DEFAULT_FILL = "#FFFFFF";
  GRID = "grid";
  AXES = "axes";
  LABEL = "label";
  FALLBACK = "fallback";
  CONTAIN = "contain";
  COVER = "cover";
  UNSIGNED_BYTE = "unsigned-byte";
  UNSIGNED_INT = "unsigned-int";
  FLOAT = "float";
  HALF_FLOAT = "half-float";
  RGBA = "rgba";
});

// src/core/main.js
class p5 {
  constructor() {
    this._lcg_random_state = null;
    this._gaussian_previous = false;
    this._colorMode = RGB;
    this._colorMaxes = {
      rgb: [255, 255, 255, 255],
      hsb: [360, 100, 100, 1],
      hsl: [360, 100, 100, 1]
    };
  }
}
var init_main = __esm(() => {
  init_constants();
  for (const k in exports_constants) {
    p5.prototype[k] = exports_constants[k];
  }
  p5.VERSION = VERSION;
});

// src/color/color_conversion.js
var color_conversion_default;
var init_color_conversion = __esm(() => {
  init_main();
  p5.ColorConversion = {
    _hsbaToHSLA(hsba) {
      const hue = hsba[0];
      let sat = hsba[1];
      const val = hsba[2];
      const li = (2 - sat) * val / 2;
      if (li !== 0) {
        if (li === 1) {
          sat = 0;
        } else if (li < 0.5) {
          sat = sat / (2 - sat);
        } else {
          sat = sat * val / (2 - li * 2);
        }
      }
      return [hue, sat, li, hsba[3]];
    },
    _hsbaToRGBA(hsba) {
      const hue = hsba[0] * 6;
      const sat = hsba[1];
      const val = hsba[2];
      let RGBA2 = [];
      if (sat === 0) {
        RGBA2 = [val, val, val, hsba[3]];
      } else {
        const sector = Math.floor(hue);
        const tint1 = val * (1 - sat);
        const tint2 = val * (1 - sat * (hue - sector));
        const tint3 = val * (1 - sat * (1 + sector - hue));
        let red, green, blue;
        if (sector === 1) {
          red = tint2;
          green = val;
          blue = tint1;
        } else if (sector === 2) {
          red = tint1;
          green = val;
          blue = tint3;
        } else if (sector === 3) {
          red = tint1;
          green = tint2;
          blue = val;
        } else if (sector === 4) {
          red = tint3;
          green = tint1;
          blue = val;
        } else if (sector === 5) {
          red = val;
          green = tint1;
          blue = tint2;
        } else {
          red = val;
          green = tint3;
          blue = tint1;
        }
        RGBA2 = [red, green, blue, hsba[3]];
      }
      return RGBA2;
    },
    _hslaToHSBA(hsla) {
      const hue = hsla[0];
      let sat = hsla[1];
      const li = hsla[2];
      let val;
      if (li < 0.5) {
        val = (1 + sat) * li;
      } else {
        val = li + sat - li * sat;
      }
      sat = 2 * (val - li) / val;
      return [hue, sat, val, hsla[3]];
    },
    _hslaToRGBA(hsla) {
      const hue = hsla[0] * 6;
      const sat = hsla[1];
      const li = hsla[2];
      let RGBA2 = [];
      if (sat === 0) {
        RGBA2 = [li, li, li, hsla[3]];
      } else {
        let val;
        if (li < 0.5) {
          val = (1 + sat) * li;
        } else {
          val = li + sat - li * sat;
        }
        const zest = 2 * li - val;
        const hzvToRGB = (hue2, zest2, val2) => {
          if (hue2 < 0) {
            hue2 += 6;
          } else if (hue2 >= 6) {
            hue2 -= 6;
          }
          if (hue2 < 1) {
            return zest2 + (val2 - zest2) * hue2;
          } else if (hue2 < 3) {
            return val2;
          } else if (hue2 < 4) {
            return zest2 + (val2 - zest2) * (4 - hue2);
          } else {
            return zest2;
          }
        };
        RGBA2 = [
          hzvToRGB(hue + 2, zest, val),
          hzvToRGB(hue, zest, val),
          hzvToRGB(hue - 2, zest, val),
          hsla[3]
        ];
      }
      return RGBA2;
    },
    _rgbaToHSBA(rgba) {
      const red = rgba[0];
      const green = rgba[1];
      const blue = rgba[2];
      const val = Math.max(red, green, blue);
      const chroma = val - Math.min(red, green, blue);
      let hue, sat;
      if (chroma === 0) {
        hue = 0;
        sat = 0;
      } else {
        sat = chroma / val;
        if (red === val) {
          hue = (green - blue) / chroma;
        } else if (green === val) {
          hue = 2 + (blue - red) / chroma;
        } else if (blue === val) {
          hue = 4 + (red - green) / chroma;
        }
        if (hue < 0) {
          hue += 6;
        } else if (hue >= 6) {
          hue -= 6;
        }
      }
      return [hue / 6, sat, val, rgba[3]];
    },
    _rgbaToHSLA(rgba) {
      const red = rgba[0];
      const green = rgba[1];
      const blue = rgba[2];
      const val = Math.max(red, green, blue);
      const min = Math.min(red, green, blue);
      const li = val + min;
      const chroma = val - min;
      let hue, sat;
      if (chroma === 0) {
        hue = 0;
        sat = 0;
      } else {
        if (li < 1) {
          sat = chroma / li;
        } else {
          sat = chroma / (2 - li);
        }
        if (red === val) {
          hue = (green - blue) / chroma;
        } else if (green === val) {
          hue = 2 + (blue - red) / chroma;
        } else if (blue === val) {
          hue = 4 + (red - green) / chroma;
        }
        if (hue < 0) {
          hue += 6;
        } else if (hue >= 6) {
          hue -= 6;
        }
      }
      return [hue / 6, sat, li / 2, rgba[3]];
    }
  };
  color_conversion_default = p5.ColorConversion;
});

// src/color/p5.Color.js
var namedColors, WHITESPACE, INTEGER, DECIMAL, PERCENT, colorPatterns, p5_Color_default;
var init_p5_Color = __esm(() => {
  init_main();
  init_constants();
  init_color_conversion();
  namedColors = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  };
  WHITESPACE = /\s*/;
  INTEGER = /(\d{1,3})/;
  DECIMAL = /((?:\d+(?:\.\d+)?)|(?:\.\d+))/;
  PERCENT = new RegExp(`${DECIMAL.source}%`);
  colorPatterns = {
    HEX3: /^#([a-f0-9])([a-f0-9])([a-f0-9])$/i,
    HEX4: /^#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])$/i,
    HEX6: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i,
    HEX8: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i,
    RGB: new RegExp([
      "^rgb\\(",
      INTEGER.source,
      ",",
      INTEGER.source,
      ",",
      INTEGER.source,
      "\\)$"
    ].join(WHITESPACE.source), "i"),
    RGB_PERCENT: new RegExp([
      "^rgb\\(",
      PERCENT.source,
      ",",
      PERCENT.source,
      ",",
      PERCENT.source,
      "\\)$"
    ].join(WHITESPACE.source), "i"),
    RGBA: new RegExp([
      "^rgba\\(",
      INTEGER.source,
      ",",
      INTEGER.source,
      ",",
      INTEGER.source,
      ",",
      DECIMAL.source,
      "\\)$"
    ].join(WHITESPACE.source), "i"),
    RGBA_PERCENT: new RegExp([
      "^rgba\\(",
      PERCENT.source,
      ",",
      PERCENT.source,
      ",",
      PERCENT.source,
      ",",
      DECIMAL.source,
      "\\)$"
    ].join(WHITESPACE.source), "i"),
    HSL: new RegExp([
      "^hsl\\(",
      INTEGER.source,
      ",",
      PERCENT.source,
      ",",
      PERCENT.source,
      "\\)$"
    ].join(WHITESPACE.source), "i"),
    HSLA: new RegExp([
      "^hsla\\(",
      INTEGER.source,
      ",",
      PERCENT.source,
      ",",
      PERCENT.source,
      ",",
      DECIMAL.source,
      "\\)$"
    ].join(WHITESPACE.source), "i"),
    HSB: new RegExp([
      "^hsb\\(",
      INTEGER.source,
      ",",
      PERCENT.source,
      ",",
      PERCENT.source,
      "\\)$"
    ].join(WHITESPACE.source), "i"),
    HSBA: new RegExp([
      "^hsba\\(",
      INTEGER.source,
      ",",
      PERCENT.source,
      ",",
      PERCENT.source,
      ",",
      DECIMAL.source,
      "\\)$"
    ].join(WHITESPACE.source), "i")
  };
  p5.Color = class Color {
    constructor(pInst, vals) {
      this._storeModeAndMaxes(pInst._colorMode, pInst._colorMaxes);
      if (![RGB, HSL, HSB].includes(this.mode)) {
        throw new Error(`${this.mode} is an invalid colorMode.`);
      } else {
        this._array = Color._parseInputs.apply(this, vals);
      }
      this._calculateLevels();
    }
    toString(format) {
      const a = this.levels;
      const f = this._array;
      const alpha = f[3];
      switch (format) {
        case "#rrggbb":
          return "#".concat(a[0] < 16 ? "0".concat(a[0].toString(16)) : a[0].toString(16), a[1] < 16 ? "0".concat(a[1].toString(16)) : a[1].toString(16), a[2] < 16 ? "0".concat(a[2].toString(16)) : a[2].toString(16));
        case "#rrggbbaa":
          return "#".concat(a[0] < 16 ? "0".concat(a[0].toString(16)) : a[0].toString(16), a[1] < 16 ? "0".concat(a[1].toString(16)) : a[1].toString(16), a[2] < 16 ? "0".concat(a[2].toString(16)) : a[2].toString(16), a[3] < 16 ? "0".concat(a[3].toString(16)) : a[3].toString(16));
        case "#rgb":
          return "#".concat(Math.round(f[0] * 15).toString(16), Math.round(f[1] * 15).toString(16), Math.round(f[2] * 15).toString(16));
        case "#rgba":
          return "#".concat(Math.round(f[0] * 15).toString(16), Math.round(f[1] * 15).toString(16), Math.round(f[2] * 15).toString(16), Math.round(f[3] * 15).toString(16));
        case "rgb":
          return "rgb(".concat(a[0], ", ", a[1], ", ", a[2], ")");
        case "rgb%":
          return "rgb(".concat((100 * f[0]).toPrecision(3), "%, ", (100 * f[1]).toPrecision(3), "%, ", (100 * f[2]).toPrecision(3), "%)");
        case "rgba%":
          return "rgba(".concat((100 * f[0]).toPrecision(3), "%, ", (100 * f[1]).toPrecision(3), "%, ", (100 * f[2]).toPrecision(3), "%, ", (100 * f[3]).toPrecision(3), "%)");
        case "hsb":
        case "hsv":
          if (!this.hsba)
            this.hsba = color_conversion_default._rgbaToHSBA(this._array);
          return "hsb(".concat(this.hsba[0] * this.maxes[HSB][0], ", ", this.hsba[1] * this.maxes[HSB][1], ", ", this.hsba[2] * this.maxes[HSB][2], ")");
        case "hsb%":
        case "hsv%":
          if (!this.hsba)
            this.hsba = color_conversion_default._rgbaToHSBA(this._array);
          return "hsb(".concat((100 * this.hsba[0]).toPrecision(3), "%, ", (100 * this.hsba[1]).toPrecision(3), "%, ", (100 * this.hsba[2]).toPrecision(3), "%)");
        case "hsba":
        case "hsva":
          if (!this.hsba)
            this.hsba = color_conversion_default._rgbaToHSBA(this._array);
          return "hsba(".concat(this.hsba[0] * this.maxes[HSB][0], ", ", this.hsba[1] * this.maxes[HSB][1], ", ", this.hsba[2] * this.maxes[HSB][2], ", ", alpha, ")");
        case "hsba%":
        case "hsva%":
          if (!this.hsba)
            this.hsba = color_conversion_default._rgbaToHSBA(this._array);
          return "hsba(".concat((100 * this.hsba[0]).toPrecision(3), "%, ", (100 * this.hsba[1]).toPrecision(3), "%, ", (100 * this.hsba[2]).toPrecision(3), "%, ", (100 * alpha).toPrecision(3), "%)");
        case "hsl":
          if (!this.hsla)
            this.hsla = color_conversion_default._rgbaToHSLA(this._array);
          return "hsl(".concat(this.hsla[0] * this.maxes[HSL][0], ", ", this.hsla[1] * this.maxes[HSL][1], ", ", this.hsla[2] * this.maxes[HSL][2], ")");
        case "hsl%":
          if (!this.hsla)
            this.hsla = color_conversion_default._rgbaToHSLA(this._array);
          return "hsl(".concat((100 * this.hsla[0]).toPrecision(3), "%, ", (100 * this.hsla[1]).toPrecision(3), "%, ", (100 * this.hsla[2]).toPrecision(3), "%)");
        case "hsla":
          if (!this.hsla)
            this.hsla = color_conversion_default._rgbaToHSLA(this._array);
          return "hsla(".concat(this.hsla[0] * this.maxes[HSL][0], ", ", this.hsla[1] * this.maxes[HSL][1], ", ", this.hsla[2] * this.maxes[HSL][2], ", ", alpha, ")");
        case "hsla%":
          if (!this.hsla)
            this.hsla = color_conversion_default._rgbaToHSLA(this._array);
          return "hsl(".concat((100 * this.hsla[0]).toPrecision(3), "%, ", (100 * this.hsla[1]).toPrecision(3), "%, ", (100 * this.hsla[2]).toPrecision(3), "%, ", (100 * alpha).toPrecision(3), "%)");
        case "rgba":
        default:
          return "rgba(".concat(a[0], ",", a[1], ",", a[2], ",", alpha, ")");
      }
    }
    setRed(new_red) {
      this._array[0] = new_red / this.maxes[RGB][0];
      this._calculateLevels();
    }
    setGreen(new_green) {
      this._array[1] = new_green / this.maxes[RGB][1];
      this._calculateLevels();
    }
    setBlue(new_blue) {
      this._array[2] = new_blue / this.maxes[RGB][2];
      this._calculateLevels();
    }
    setAlpha(new_alpha) {
      this._array[3] = new_alpha / this.maxes[this.mode][3];
      this._calculateLevels();
    }
    _calculateLevels() {
      const array = this._array;
      const levels = this.levels = new Array(array.length);
      for (let i = array.length - 1;i >= 0; --i) {
        levels[i] = Math.round(array[i] * 255);
      }
      this.hsla = null;
      this.hsba = null;
    }
    _getAlpha() {
      return this._array[3] * this.maxes[this.mode][3];
    }
    _storeModeAndMaxes(new_mode, new_maxes) {
      this.mode = new_mode;
      this.maxes = new_maxes;
    }
    _getMode() {
      return this.mode;
    }
    _getMaxes() {
      return this.maxes;
    }
    _getBlue() {
      return this._array[2] * this.maxes[RGB][2];
    }
    _getBrightness() {
      if (!this.hsba) {
        this.hsba = color_conversion_default._rgbaToHSBA(this._array);
      }
      return this.hsba[2] * this.maxes[HSB][2];
    }
    _getGreen() {
      return this._array[1] * this.maxes[RGB][1];
    }
    _getHue() {
      if (this.mode === HSB) {
        if (!this.hsba) {
          this.hsba = color_conversion_default._rgbaToHSBA(this._array);
        }
        return this.hsba[0] * this.maxes[HSB][0];
      } else {
        if (!this.hsla) {
          this.hsla = color_conversion_default._rgbaToHSLA(this._array);
        }
        return this.hsla[0] * this.maxes[HSL][0];
      }
    }
    _getLightness() {
      if (!this.hsla) {
        this.hsla = color_conversion_default._rgbaToHSLA(this._array);
      }
      return this.hsla[2] * this.maxes[HSL][2];
    }
    _getRed() {
      return this._array[0] * this.maxes[RGB][0];
    }
    _getSaturation() {
      if (this.mode === HSB) {
        if (!this.hsba) {
          this.hsba = color_conversion_default._rgbaToHSBA(this._array);
        }
        return this.hsba[1] * this.maxes[HSB][1];
      } else {
        if (!this.hsla) {
          this.hsla = color_conversion_default._rgbaToHSLA(this._array);
        }
        return this.hsla[1] * this.maxes[HSL][1];
      }
    }
    static _parseInputs(r, g, b, a) {
      const numArgs = arguments.length;
      const mode = this.mode;
      const maxes = this.maxes[mode];
      let results = [];
      let i;
      if (numArgs >= 3) {
        results[0] = r / maxes[0];
        results[1] = g / maxes[1];
        results[2] = b / maxes[2];
        if (typeof a === "number") {
          results[3] = a / maxes[3];
        } else {
          results[3] = 1;
        }
        for (i = results.length - 1;i >= 0; --i) {
          const result = results[i];
          if (result < 0) {
            results[i] = 0;
          } else if (result > 1) {
            results[i] = 1;
          }
        }
        if (mode === HSL) {
          return color_conversion_default._hslaToRGBA(results);
        } else if (mode === HSB) {
          return color_conversion_default._hsbaToRGBA(results);
        } else {
          return results;
        }
      } else if (numArgs === 1 && typeof r === "string") {
        const str = r.trim().toLowerCase();
        if (namedColors[str]) {
          return Color._parseInputs.call(this, namedColors[str]);
        }
        if (colorPatterns.HEX3.test(str)) {
          results = colorPatterns.HEX3.exec(str).slice(1).map((color) => parseInt(color + color, 16) / 255);
          results[3] = 1;
          return results;
        } else if (colorPatterns.HEX6.test(str)) {
          results = colorPatterns.HEX6.exec(str).slice(1).map((color) => parseInt(color, 16) / 255);
          results[3] = 1;
          return results;
        } else if (colorPatterns.HEX4.test(str)) {
          results = colorPatterns.HEX4.exec(str).slice(1).map((color) => parseInt(color + color, 16) / 255);
          return results;
        } else if (colorPatterns.HEX8.test(str)) {
          results = colorPatterns.HEX8.exec(str).slice(1).map((color) => parseInt(color, 16) / 255);
          return results;
        } else if (colorPatterns.RGB.test(str)) {
          results = colorPatterns.RGB.exec(str).slice(1).map((color) => color / 255);
          results[3] = 1;
          return results;
        } else if (colorPatterns.RGB_PERCENT.test(str)) {
          results = colorPatterns.RGB_PERCENT.exec(str).slice(1).map((color) => parseFloat(color) / 100);
          results[3] = 1;
          return results;
        } else if (colorPatterns.RGBA.test(str)) {
          results = colorPatterns.RGBA.exec(str).slice(1).map((color, idx) => {
            if (idx === 3) {
              return parseFloat(color);
            }
            return color / 255;
          });
          return results;
        } else if (colorPatterns.RGBA_PERCENT.test(str)) {
          results = colorPatterns.RGBA_PERCENT.exec(str).slice(1).map((color, idx) => {
            if (idx === 3) {
              return parseFloat(color);
            }
            return parseFloat(color) / 100;
          });
          return results;
        }
        if (colorPatterns.HSL.test(str)) {
          results = colorPatterns.HSL.exec(str).slice(1).map((color, idx) => {
            if (idx === 0) {
              return parseInt(color, 10) / 360;
            }
            return parseInt(color, 10) / 100;
          });
          results[3] = 1;
        } else if (colorPatterns.HSLA.test(str)) {
          results = colorPatterns.HSLA.exec(str).slice(1).map((color, idx) => {
            if (idx === 0) {
              return parseInt(color, 10) / 360;
            } else if (idx === 3) {
              return parseFloat(color);
            }
            return parseInt(color, 10) / 100;
          });
        }
        results = results.map((value) => Math.max(Math.min(value, 1), 0));
        if (results.length) {
          return color_conversion_default._hslaToRGBA(results);
        }
        if (colorPatterns.HSB.test(str)) {
          results = colorPatterns.HSB.exec(str).slice(1).map((color, idx) => {
            if (idx === 0) {
              return parseInt(color, 10) / 360;
            }
            return parseInt(color, 10) / 100;
          });
          results[3] = 1;
        } else if (colorPatterns.HSBA.test(str)) {
          results = colorPatterns.HSBA.exec(str).slice(1).map((color, idx) => {
            if (idx === 0) {
              return parseInt(color, 10) / 360;
            } else if (idx === 3) {
              return parseFloat(color);
            }
            return parseInt(color, 10) / 100;
          });
        }
        if (results.length) {
          for (i = results.length - 1;i >= 0; --i) {
            results[i] = Math.max(Math.min(results[i], 1), 0);
          }
          return color_conversion_default._hsbaToRGBA(results);
        }
        results = [1, 1, 1, 1];
      } else if ((numArgs === 1 || numArgs === 2) && typeof r === "number") {
        results[0] = r / maxes[2];
        results[1] = r / maxes[2];
        results[2] = r / maxes[2];
        if (typeof g === "number") {
          results[3] = g / maxes[3];
        } else {
          results[3] = 1;
        }
        results = results.map((value) => Math.max(Math.min(value, 1), 0));
      } else {
        throw new Error(`${arguments}is not a valid color representation.`);
      }
      return results;
    }
  };
  p5_Color_default = p5.Color;
});

// src/color/creating_reading.js
var init_creating_reading = __esm(() => {
  init_main();
  init_constants();
  init_p5_Color();
  p5.prototype.alpha = function(c) {
    return this.color(c)._getAlpha();
  };
  p5.prototype.blue = function(c) {
    return this.color(c)._getBlue();
  };
  p5.prototype.brightness = function(c) {
    return this.color(c)._getBrightness();
  };
  p5.prototype.color = function(...args) {
    if (args[0] instanceof p5.Color) {
      return args[0];
    }
    const arg = Array.isArray(args[0]) ? args[0] : args;
    return new p5.Color(this, arg);
  };
  p5.prototype.green = function(c) {
    return this.color(c)._getGreen();
  };
  p5.prototype.hue = function(c) {
    return this.color(c)._getHue();
  };
  p5.prototype.lerpColor = function(c1, c2, amt) {
    const mode = this._colorMode;
    const maxes = this._colorMaxes;
    let l0, l1, l2, l3;
    let fromArray, toArray;
    if (mode === RGB) {
      fromArray = c1.levels.map((level) => level / 255);
      toArray = c2.levels.map((level) => level / 255);
    } else if (mode === HSB) {
      c1._getBrightness();
      c2._getBrightness();
      fromArray = c1.hsba;
      toArray = c2.hsba;
    } else if (mode === HSL) {
      c1._getLightness();
      c2._getLightness();
      fromArray = c1.hsla;
      toArray = c2.hsla;
    } else {
      throw new Error(`${mode} cannot be used for interpolation.`);
    }
    amt = Math.max(Math.min(amt, 1), 0);
    if (typeof this.lerp === "undefined") {
      this.lerp = (start, stop, amt2) => amt2 * (stop - start) + start;
    }
    if (mode === RGB) {
      l0 = this.lerp(fromArray[0], toArray[0], amt);
    } else {
      if (Math.abs(fromArray[0] - toArray[0]) > 0.5) {
        if (fromArray[0] > toArray[0]) {
          toArray[0] += 1;
        } else {
          fromArray[0] += 1;
        }
      }
      l0 = this.lerp(fromArray[0], toArray[0], amt);
      if (l0 >= 1) {
        l0 -= 1;
      }
    }
    l1 = this.lerp(fromArray[1], toArray[1], amt);
    l2 = this.lerp(fromArray[2], toArray[2], amt);
    l3 = this.lerp(fromArray[3], toArray[3], amt);
    l0 *= maxes[mode][0];
    l1 *= maxes[mode][1];
    l2 *= maxes[mode][2];
    l3 *= maxes[mode][3];
    return this.color(l0, l1, l2, l3);
  };
  p5.prototype.lightness = function(c) {
    return this.color(c)._getLightness();
  };
  p5.prototype.red = function(c) {
    return this.color(c)._getRed();
  };
  p5.prototype.saturation = function(c) {
    return this.color(c)._getSaturation();
  };
});

// src/math/calculation.js
var init_calculation = __esm(() => {
  init_main();
  p5.prototype.abs = Math.abs;
  p5.prototype.ceil = Math.ceil;
  p5.prototype.constrain = function(n, low, high) {
    p5._validateParameters("constrain", arguments);
    return Math.max(Math.min(n, high), low);
  };
  p5.prototype.dist = function(...args) {
    p5._validateParameters("dist", args);
    if (args.length === 4) {
      return Math.hypot(args[2] - args[0], args[3] - args[1]);
    } else if (args.length === 6) {
      return Math.hypot(args[3] - args[0], args[4] - args[1], args[5] - args[2]);
    }
  };
  p5.prototype.exp = Math.exp;
  p5.prototype.floor = Math.floor;
  p5.prototype.lerp = function(start, stop, amt) {
    p5._validateParameters("lerp", arguments);
    return amt * (stop - start) + start;
  };
  p5.prototype.log = Math.log;
  p5.prototype.mag = function(x, y) {
    p5._validateParameters("mag", arguments);
    return Math.hypot(x, y);
  };
  p5.prototype.map = function(n, start1, stop1, start2, stop2, withinBounds) {
    p5._validateParameters("map", arguments);
    const newval = (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;
    if (!withinBounds) {
      return newval;
    }
    if (start2 < stop2) {
      return this.constrain(newval, start2, stop2);
    } else {
      return this.constrain(newval, stop2, start2);
    }
  };
  p5.prototype.max = function(...args) {
    const findMax = (arr) => Math.max(...arr);
    if (Array.isArray(args[0])) {
      return findMax(args[0]);
    } else {
      return findMax(args);
    }
  };
  p5.prototype.min = function(...args) {
    const findMin = (arr) => Math.min(...arr);
    if (Array.isArray(args[0])) {
      return findMin(args[0]);
    } else {
      return findMin(args);
    }
  };
  p5.prototype.norm = function(n, start, stop) {
    p5._validateParameters("norm", arguments);
    return this.map(n, start, stop, 0, 1);
  };
  p5.prototype.pow = Math.pow;
  p5.prototype.round = function(n, decimals) {
    if (!decimals) {
      return Math.round(n);
    }
    const multiplier = Math.pow(10, decimals);
    return Math.round(n * multiplier) / multiplier;
  };
  p5.prototype.sq = (n) => n * n;
  p5.prototype.sqrt = Math.sqrt;
  p5.prototype.fract = function(toConvert) {
    p5._validateParameters("fract", arguments);
    let sign = 0;
    let num = Number(toConvert);
    if (isNaN(num) || Math.abs(num) === Infinity) {
      return num;
    } else if (num < 0) {
      num = -num;
      sign = 1;
    }
    if (String(num).includes(".") && !String(num).includes("e")) {
      let toFract = String(num);
      toFract = Number("0" + toFract.slice(toFract.indexOf(".")));
      return Math.abs(sign - toFract);
    } else if (num < 1) {
      return Math.abs(sign - num);
    } else {
      return 0;
    }
  };
});

// src/math/math.js
var init_math = __esm(() => {
  init_main();
  p5.prototype.createVector = function(x, y, z) {
    if (this instanceof p5) {
      return new p5.Vector(this._fromRadians.bind(this), this._toRadians.bind(this), ...arguments);
    } else {
      return new p5.Vector(x, y, z);
    }
  };
});

// src/math/noise.js
var PERLIN_YWRAPB, PERLIN_YWRAP, PERLIN_ZWRAPB, PERLIN_ZWRAP, PERLIN_SIZE, perlin_octaves, perlin_amp_falloff, scaled_cosine, perlin;
var init_noise = __esm(() => {
  init_main();
  PERLIN_YWRAPB = 4;
  PERLIN_YWRAP = 1 << PERLIN_YWRAPB;
  PERLIN_ZWRAPB = 8;
  PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;
  PERLIN_SIZE = 4095;
  perlin_octaves = 4;
  perlin_amp_falloff = 0.5;
  scaled_cosine = (i) => 0.5 * (1 - Math.cos(i * Math.PI));
  p5.prototype.noise = function(x, y = 0, z = 0) {
    if (perlin == null) {
      perlin = new Array(PERLIN_SIZE + 1);
      for (let i = 0;i < PERLIN_SIZE + 1; i++) {
        perlin[i] = Math.random();
      }
    }
    if (x < 0) {
      x = -x;
    }
    if (y < 0) {
      y = -y;
    }
    if (z < 0) {
      z = -z;
    }
    let xi = Math.floor(x), yi = Math.floor(y), zi = Math.floor(z);
    let xf = x - xi;
    let yf = y - yi;
    let zf = z - zi;
    let rxf, ryf;
    let r = 0;
    let ampl = 0.5;
    let n1, n2, n3;
    for (let o = 0;o < perlin_octaves; o++) {
      let of = xi + (yi << PERLIN_YWRAPB) + (zi << PERLIN_ZWRAPB);
      rxf = scaled_cosine(xf);
      ryf = scaled_cosine(yf);
      n1 = perlin[of & PERLIN_SIZE];
      n1 += rxf * (perlin[of + 1 & PERLIN_SIZE] - n1);
      n2 = perlin[of + PERLIN_YWRAP & PERLIN_SIZE];
      n2 += rxf * (perlin[of + PERLIN_YWRAP + 1 & PERLIN_SIZE] - n2);
      n1 += ryf * (n2 - n1);
      of += PERLIN_ZWRAP;
      n2 = perlin[of & PERLIN_SIZE];
      n2 += rxf * (perlin[of + 1 & PERLIN_SIZE] - n2);
      n3 = perlin[of + PERLIN_YWRAP & PERLIN_SIZE];
      n3 += rxf * (perlin[of + PERLIN_YWRAP + 1 & PERLIN_SIZE] - n3);
      n2 += ryf * (n3 - n2);
      n1 += scaled_cosine(zf) * (n2 - n1);
      r += n1 * ampl;
      ampl *= perlin_amp_falloff;
      xi <<= 1;
      xf *= 2;
      yi <<= 1;
      yf *= 2;
      zi <<= 1;
      zf *= 2;
      if (xf >= 1) {
        xi++;
        xf--;
      }
      if (yf >= 1) {
        yi++;
        yf--;
      }
      if (zf >= 1) {
        zi++;
        zf--;
      }
    }
    return r;
  };
  p5.prototype.noiseDetail = function(lod, falloff) {
    if (lod > 0) {
      perlin_octaves = lod;
    }
    if (falloff > 0) {
      perlin_amp_falloff = falloff;
    }
  };
  p5.prototype.noiseSeed = function(seed) {
    const lcg = (() => {
      const m = 4294967296;
      const a = 1664525;
      const c = 1013904223;
      let seed2, z;
      return {
        setSeed(val) {
          z = seed2 = (val == null ? Math.random() * m : val) >>> 0;
        },
        getSeed() {
          return seed2;
        },
        rand() {
          z = (a * z + c) % m;
          return z / m;
        }
      };
    })();
    lcg.setSeed(seed);
    perlin = new Array(PERLIN_SIZE + 1);
    for (let i = 0;i < PERLIN_SIZE + 1; i++) {
      perlin[i] = lcg.rand();
    }
  };
});

// src/math/p5.Vector.js
var p5_Vector_default;
var init_p5_Vector = __esm(() => {
  init_main();
  init_constants();
  p5.Vector = class {
    constructor(...args) {
      let x, y, z;
      if (typeof args[0] === "function") {
        this.isPInst = true;
        this._fromRadians = args[0];
        this._toRadians = args[1];
        x = args[2] || 0;
        y = args[3] || 0;
        z = args[4] || 0;
      } else {
        x = args[0] || 0;
        y = args[1] || 0;
        z = args[2] || 0;
      }
      this.x = x;
      this.y = y;
      this.z = z;
    }
    toString() {
      return `p5.Vector Object : [${this.x}, ${this.y}, ${this.z}]`;
    }
    set(x, y, z) {
      if (x instanceof p5.Vector) {
        this.x = x.x || 0;
        this.y = x.y || 0;
        this.z = x.z || 0;
        return this;
      }
      if (Array.isArray(x)) {
        this.x = x[0] || 0;
        this.y = x[1] || 0;
        this.z = x[2] || 0;
        return this;
      }
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
      return this;
    }
    copy() {
      if (this.isPInst) {
        return new p5.Vector(this._fromRadians, this._toRadians, this.x, this.y, this.z);
      } else {
        return new p5.Vector(this.x, this.y, this.z);
      }
    }
    add(x, y, z) {
      if (x instanceof p5.Vector) {
        this.x += x.x || 0;
        this.y += x.y || 0;
        this.z += x.z || 0;
        return this;
      }
      if (Array.isArray(x)) {
        this.x += x[0] || 0;
        this.y += x[1] || 0;
        this.z += x[2] || 0;
        return this;
      }
      this.x += x || 0;
      this.y += y || 0;
      this.z += z || 0;
      return this;
    }
    calculateRemainder2D(xComponent, yComponent) {
      if (xComponent !== 0) {
        this.x = this.x % xComponent;
      }
      if (yComponent !== 0) {
        this.y = this.y % yComponent;
      }
      return this;
    }
    calculateRemainder3D(xComponent, yComponent, zComponent) {
      if (xComponent !== 0) {
        this.x = this.x % xComponent;
      }
      if (yComponent !== 0) {
        this.y = this.y % yComponent;
      }
      if (zComponent !== 0) {
        this.z = this.z % zComponent;
      }
      return this;
    }
    rem(x, y, z) {
      if (x instanceof p5.Vector) {
        if ([x.x, x.y, x.z].every(Number.isFinite)) {
          const xComponent = parseFloat(x.x);
          const yComponent = parseFloat(x.y);
          const zComponent = parseFloat(x.z);
          return this.calculateRemainder3D(xComponent, yComponent, zComponent);
        }
      } else if (Array.isArray(x)) {
        if (x.every((element) => Number.isFinite(element))) {
          if (x.length === 2) {
            return this.calculateRemainder2D(x[0], x[1]);
          }
          if (x.length === 3) {
            return this.calculateRemainder3D(x[0], x[1], x[2]);
          }
        }
      } else if (arguments.length === 1) {
        if (Number.isFinite(arguments[0]) && arguments[0] !== 0) {
          this.x = this.x % arguments[0];
          this.y = this.y % arguments[0];
          this.z = this.z % arguments[0];
          return this;
        }
      } else if (arguments.length === 2) {
        const vectorComponents = [...arguments];
        if (vectorComponents.every((element) => Number.isFinite(element))) {
          if (vectorComponents.length === 2) {
            return this.calculateRemainder2D(vectorComponents[0], vectorComponents[1]);
          }
        }
      } else if (arguments.length === 3) {
        const vectorComponents = [...arguments];
        if (vectorComponents.every((element) => Number.isFinite(element))) {
          if (vectorComponents.length === 3) {
            return this.calculateRemainder3D(vectorComponents[0], vectorComponents[1], vectorComponents[2]);
          }
        }
      }
    }
    sub(x, y, z) {
      if (x instanceof p5.Vector) {
        this.x -= x.x || 0;
        this.y -= x.y || 0;
        this.z -= x.z || 0;
        return this;
      }
      if (Array.isArray(x)) {
        this.x -= x[0] || 0;
        this.y -= x[1] || 0;
        this.z -= x[2] || 0;
        return this;
      }
      this.x -= x || 0;
      this.y -= y || 0;
      this.z -= z || 0;
      return this;
    }
    mult(x, y, z) {
      if (x instanceof p5.Vector) {
        if (Number.isFinite(x.x) && Number.isFinite(x.y) && Number.isFinite(x.z) && typeof x.x === "number" && typeof x.y === "number" && typeof x.z === "number") {
          this.x *= x.x;
          this.y *= x.y;
          this.z *= x.z;
        } else {
          console.warn("p5.Vector.prototype.mult:", "x contains components that are either undefined or not finite numbers");
        }
        return this;
      }
      if (Array.isArray(x)) {
        if (x.every((element) => Number.isFinite(element)) && x.every((element) => typeof element === "number")) {
          if (x.length === 1) {
            this.x *= x[0];
            this.y *= x[0];
            this.z *= x[0];
          } else if (x.length === 2) {
            this.x *= x[0];
            this.y *= x[1];
          } else if (x.length === 3) {
            this.x *= x[0];
            this.y *= x[1];
            this.z *= x[2];
          }
        } else {
          console.warn("p5.Vector.prototype.mult:", "x contains elements that are either undefined or not finite numbers");
        }
        return this;
      }
      const vectorComponents = [...arguments];
      if (vectorComponents.every((element) => Number.isFinite(element)) && vectorComponents.every((element) => typeof element === "number")) {
        if (arguments.length === 1) {
          this.x *= x;
          this.y *= x;
          this.z *= x;
        }
        if (arguments.length === 2) {
          this.x *= x;
          this.y *= y;
        }
        if (arguments.length === 3) {
          this.x *= x;
          this.y *= y;
          this.z *= z;
        }
      } else {
        console.warn("p5.Vector.prototype.mult:", "x, y, or z arguments are either undefined or not a finite number");
      }
      return this;
    }
    div(x, y, z) {
      if (x instanceof p5.Vector) {
        if (Number.isFinite(x.x) && Number.isFinite(x.y) && Number.isFinite(x.z) && typeof x.x === "number" && typeof x.y === "number" && typeof x.z === "number") {
          const isLikely2D = x.z === 0 && this.z === 0;
          if (x.x === 0 || x.y === 0 || !isLikely2D && x.z === 0) {
            console.warn("p5.Vector.prototype.div:", "divide by 0");
            return this;
          }
          this.x /= x.x;
          this.y /= x.y;
          if (!isLikely2D) {
            this.z /= x.z;
          }
        } else {
          console.warn("p5.Vector.prototype.div:", "x contains components that are either undefined or not finite numbers");
        }
        return this;
      }
      if (Array.isArray(x)) {
        if (x.every((element) => Number.isFinite(element)) && x.every((element) => typeof element === "number")) {
          if (x.some((element) => element === 0)) {
            console.warn("p5.Vector.prototype.div:", "divide by 0");
            return this;
          }
          if (x.length === 1) {
            this.x /= x[0];
            this.y /= x[0];
            this.z /= x[0];
          } else if (x.length === 2) {
            this.x /= x[0];
            this.y /= x[1];
          } else if (x.length === 3) {
            this.x /= x[0];
            this.y /= x[1];
            this.z /= x[2];
          }
        } else {
          console.warn("p5.Vector.prototype.div:", "x contains components that are either undefined or not finite numbers");
        }
        return this;
      }
      const vectorComponents = [...arguments];
      if (vectorComponents.every((element) => Number.isFinite(element)) && vectorComponents.every((element) => typeof element === "number")) {
        if (vectorComponents.some((element) => element === 0)) {
          console.warn("p5.Vector.prototype.div:", "divide by 0");
          return this;
        }
        if (arguments.length === 1) {
          this.x /= x;
          this.y /= x;
          this.z /= x;
        }
        if (arguments.length === 2) {
          this.x /= x;
          this.y /= y;
        }
        if (arguments.length === 3) {
          this.x /= x;
          this.y /= y;
          this.z /= z;
        }
      } else {
        console.warn("p5.Vector.prototype.div:", "x, y, or z arguments are either undefined or not a finite number");
      }
      return this;
    }
    mag() {
      return Math.sqrt(this.magSq());
    }
    magSq() {
      const x = this.x;
      const y = this.y;
      const z = this.z;
      return x * x + y * y + z * z;
    }
    dot(x, y, z) {
      if (x instanceof p5.Vector) {
        return this.dot(x.x, x.y, x.z);
      }
      return this.x * (x || 0) + this.y * (y || 0) + this.z * (z || 0);
    }
    cross(v) {
      const x = this.y * v.z - this.z * v.y;
      const y = this.z * v.x - this.x * v.z;
      const z = this.x * v.y - this.y * v.x;
      if (this.isPInst) {
        return new p5.Vector(this._fromRadians, this._toRadians, x, y, z);
      } else {
        return new p5.Vector(x, y, z);
      }
    }
    dist(v) {
      return v.copy().sub(this).mag();
    }
    normalize() {
      const len = this.mag();
      if (len !== 0)
        this.mult(1 / len);
      return this;
    }
    limit(max) {
      const mSq = this.magSq();
      if (mSq > max * max) {
        this.div(Math.sqrt(mSq)).mult(max);
      }
      return this;
    }
    setMag(n) {
      return this.normalize().mult(n);
    }
    heading() {
      const h = Math.atan2(this.y, this.x);
      if (this.isPInst)
        return this._fromRadians(h);
      return h;
    }
    setHeading(a) {
      if (this.isPInst)
        a = this._toRadians(a);
      let m = this.mag();
      this.x = m * Math.cos(a);
      this.y = m * Math.sin(a);
      return this;
    }
    rotate(a) {
      let newHeading = this.heading() + a;
      if (this.isPInst)
        newHeading = this._toRadians(newHeading);
      const mag = this.mag();
      this.x = Math.cos(newHeading) * mag;
      this.y = Math.sin(newHeading) * mag;
      return this;
    }
    angleBetween(v) {
      const magSqMult = this.magSq() * v.magSq();
      if (magSqMult === 0) {
        return NaN;
      }
      const u = this.cross(v);
      let angle = Math.atan2(u.mag(), this.dot(v)) * Math.sign(u.z || 1);
      if (this.isPInst) {
        angle = this._fromRadians(angle);
      }
      return angle;
    }
    lerp(x, y, z, amt) {
      if (x instanceof p5.Vector) {
        return this.lerp(x.x, x.y, x.z, y);
      }
      this.x += (x - this.x) * amt || 0;
      this.y += (y - this.y) * amt || 0;
      this.z += (z - this.z) * amt || 0;
      return this;
    }
    slerp(v, amt) {
      if (amt === 0) {
        return this;
      }
      if (amt === 1) {
        return this.set(v);
      }
      const selfMag = this.mag();
      const vMag = v.mag();
      const magmag = selfMag * vMag;
      if (magmag === 0) {
        this.mult(1 - amt).add(v.x * amt, v.y * amt, v.z * amt);
        return this;
      }
      const axis = this.cross(v);
      const axisMag = axis.mag();
      const theta = Math.atan2(axisMag, this.dot(v));
      if (axisMag > 0) {
        axis.x /= axisMag;
        axis.y /= axisMag;
        axis.z /= axisMag;
      } else if (theta < Math.PI * 0.5) {
        this.mult(1 - amt).add(v.x * amt, v.y * amt, v.z * amt);
        return this;
      } else {
        if (this.z === 0 && v.z === 0) {
          axis.set(0, 0, 1);
        } else if (this.x !== 0) {
          axis.set(this.y, -this.x, 0).normalize();
        } else {
          axis.set(1, 0, 0);
        }
      }
      const ey = axis.cross(this);
      const lerpedMagFactor = 1 - amt + amt * vMag / selfMag;
      const cosMultiplier = lerpedMagFactor * Math.cos(amt * theta);
      const sinMultiplier = lerpedMagFactor * Math.sin(amt * theta);
      this.x = this.x * cosMultiplier + ey.x * sinMultiplier;
      this.y = this.y * cosMultiplier + ey.y * sinMultiplier;
      this.z = this.z * cosMultiplier + ey.z * sinMultiplier;
      return this;
    }
    reflect(surfaceNormal) {
      surfaceNormal.normalize();
      return this.sub(surfaceNormal.mult(2 * this.dot(surfaceNormal)));
    }
    array() {
      return [this.x || 0, this.y || 0, this.z || 0];
    }
    equals(x, y, z) {
      let a, b, c;
      if (x instanceof p5.Vector) {
        a = x.x || 0;
        b = x.y || 0;
        c = x.z || 0;
      } else if (Array.isArray(x)) {
        a = x[0] || 0;
        b = x[1] || 0;
        c = x[2] || 0;
      } else {
        a = x || 0;
        b = y || 0;
        c = z || 0;
      }
      return this.x === a && this.y === b && this.z === c;
    }
    static fromAngle(angle, length) {
      if (typeof length === "undefined") {
        length = 1;
      }
      return new p5.Vector(length * Math.cos(angle), length * Math.sin(angle), 0);
    }
    static fromAngles(theta, phi, length) {
      if (typeof length === "undefined") {
        length = 1;
      }
      const cosPhi = Math.cos(phi);
      const sinPhi = Math.sin(phi);
      const cosTheta = Math.cos(theta);
      const sinTheta = Math.sin(theta);
      return new p5.Vector(length * sinTheta * sinPhi, -length * cosTheta, length * sinTheta * cosPhi);
    }
    static random2D() {
      return this.fromAngle(Math.random() * TWO_PI);
    }
    static random3D() {
      const angle = Math.random() * TWO_PI;
      const vz = Math.random() * 2 - 1;
      const vzBase = Math.sqrt(1 - vz * vz);
      const vx = vzBase * Math.cos(angle);
      const vy = vzBase * Math.sin(angle);
      return new p5.Vector(vx, vy, vz);
    }
    static copy(v) {
      return v.copy(v);
    }
    static add(v1, v2, target) {
      if (!target) {
        target = v1.copy();
        if (arguments.length === 3) {
          p5._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.add");
        }
      } else {
        target.set(v1);
      }
      target.add(v2);
      return target;
    }
    static rem(v1, v2) {
      if (v1 instanceof p5.Vector && v2 instanceof p5.Vector) {
        let target = v1.copy();
        target.rem(v2);
        return target;
      }
    }
    static sub(v1, v2, target) {
      if (!target) {
        target = v1.copy();
        if (arguments.length === 3) {
          p5._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.sub");
        }
      } else {
        target.set(v1);
      }
      target.sub(v2);
      return target;
    }
    static mult(v, n, target) {
      if (!target) {
        target = v.copy();
        if (arguments.length === 3) {
          p5._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.mult");
        }
      } else {
        target.set(v);
      }
      target.mult(n);
      return target;
    }
    static rotate(v, a, target) {
      if (arguments.length === 2) {
        target = v.copy();
      } else {
        if (!(target instanceof p5.Vector)) {
          p5._friendlyError("The target parameter should be of type p5.Vector", "p5.Vector.rotate");
        }
        target.set(v);
      }
      target.rotate(a);
      return target;
    }
    static div(v, n, target) {
      if (!target) {
        target = v.copy();
        if (arguments.length === 3) {
          p5._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.div");
        }
      } else {
        target.set(v);
      }
      target.div(n);
      return target;
    }
    static dot(v1, v2) {
      return v1.dot(v2);
    }
    static cross(v1, v2) {
      return v1.cross(v2);
    }
    static dist(v1, v2) {
      return v1.dist(v2);
    }
    static lerp(v1, v2, amt, target) {
      if (!target) {
        target = v1.copy();
        if (arguments.length === 4) {
          p5._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.lerp");
        }
      } else {
        target.set(v1);
      }
      target.lerp(v2, amt);
      return target;
    }
    static slerp(v1, v2, amt, target) {
      if (!target) {
        target = v1.copy();
        if (arguments.length === 4) {
          p5._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.slerp");
        }
      } else {
        target.set(v1);
      }
      target.slerp(v2, amt);
      return target;
    }
    static mag(vecT) {
      return vecT.mag();
    }
    static magSq(vecT) {
      return vecT.magSq();
    }
    static normalize(v, target) {
      if (arguments.length < 2) {
        target = v.copy();
      } else {
        if (!(target instanceof p5.Vector)) {
          p5._friendlyError("The target parameter should be of type p5.Vector", "p5.Vector.normalize");
        }
        target.set(v);
      }
      return target.normalize();
    }
    static limit(v, max, target) {
      if (arguments.length < 3) {
        target = v.copy();
      } else {
        if (!(target instanceof p5.Vector)) {
          p5._friendlyError("The target parameter should be of type p5.Vector", "p5.Vector.limit");
        }
        target.set(v);
      }
      return target.limit(max);
    }
    static setMag(v, len, target) {
      if (arguments.length < 3) {
        target = v.copy();
      } else {
        if (!(target instanceof p5.Vector)) {
          p5._friendlyError("The target parameter should be of type p5.Vector", "p5.Vector.setMag");
        }
        target.set(v);
      }
      return target.setMag(len);
    }
    static heading(v) {
      return v.heading();
    }
    static angleBetween(v1, v2) {
      return v1.angleBetween(v2);
    }
    static reflect(incidentVector, surfaceNormal, target) {
      if (arguments.length < 3) {
        target = incidentVector.copy();
      } else {
        if (!(target instanceof p5.Vector)) {
          p5._friendlyError("The target parameter should be of type p5.Vector", "p5.Vector.reflect");
        }
        target.set(incidentVector);
      }
      return target.reflect(surfaceNormal);
    }
    static array(v) {
      return v.array();
    }
    static equals(v1, v2) {
      let v;
      if (v1 instanceof p5.Vector) {
        v = v1;
      } else if (Array.isArray(v1)) {
        v = new p5.Vector().set(v1);
      } else {
        p5._friendlyError("The v1 parameter should be of type Array or p5.Vector", "p5.Vector.equals");
      }
      return v.equals(v2);
    }
  };
  p5_Vector_default = p5.Vector;
});

// src/math/random.js
var randomStateProp, m, a, c, y2;
var init_random = __esm(() => {
  init_main();
  randomStateProp = "_lcg_random_state";
  m = 4294967296;
  a = 1664525;
  c = 1013904223;
  y2 = 0;
  p5.prototype._lcg = function(stateProperty) {
    this[stateProperty] = (a * this[stateProperty] + c) % m;
    return this[stateProperty] / m;
  };
  p5.prototype._lcgSetSeed = function(stateProperty, val) {
    this[stateProperty] = (val == null ? Math.random() * m : val) >>> 0;
  };
  p5.prototype.randomSeed = function(seed) {
    this._lcgSetSeed(randomStateProp, seed);
    this._gaussian_previous = false;
  };
  p5.prototype.random = function(min, max) {
    p5._validateParameters("random", arguments);
    let rand;
    if (this[randomStateProp] != null) {
      rand = this._lcg(randomStateProp);
    } else {
      rand = Math.random();
    }
    if (typeof min === "undefined") {
      return rand;
    } else if (typeof max === "undefined") {
      if (Array.isArray(min)) {
        return min[Math.floor(rand * min.length)];
      } else {
        return rand * min;
      }
    } else {
      if (min > max) {
        const tmp = min;
        min = max;
        max = tmp;
      }
      return rand * (max - min) + min;
    }
  };
  p5.prototype.randomGaussian = function(mean, sd = 1) {
    let y1, x1, x2, w;
    if (this._gaussian_previous) {
      y1 = y2;
      this._gaussian_previous = false;
    } else {
      do {
        x1 = this.random(2) - 1;
        x2 = this.random(2) - 1;
        w = x1 * x1 + x2 * x2;
      } while (w >= 1);
      w = Math.sqrt(-2 * Math.log(w) / w);
      y1 = x1 * w;
      y2 = x2 * w;
      this._gaussian_previous = true;
    }
    const m2 = mean || 0;
    return y1 * sd + m2;
  };
});

// src/math/trigonometry.js
var init_trigonometry = __esm(() => {
  init_main();
  init_constants();
  p5.prototype._angleMode = RADIANS;
  p5.prototype.acos = function(ratio) {
    return this._fromRadians(Math.acos(ratio));
  };
  p5.prototype.asin = function(ratio) {
    return this._fromRadians(Math.asin(ratio));
  };
  p5.prototype.atan = function(ratio) {
    return this._fromRadians(Math.atan(ratio));
  };
  p5.prototype.atan2 = function(y, x) {
    return this._fromRadians(Math.atan2(y, x));
  };
  p5.prototype.cos = function(angle) {
    return Math.cos(this._toRadians(angle));
  };
  p5.prototype.sin = function(angle) {
    return Math.sin(this._toRadians(angle));
  };
  p5.prototype.tan = function(angle) {
    return Math.tan(this._toRadians(angle));
  };
  p5.prototype.degrees = (angle) => angle * RAD_TO_DEG;
  p5.prototype.radians = (angle) => angle * DEG_TO_RAD;
  p5.prototype.angleMode = function(mode) {
    p5._validateParameters("angleMode", arguments);
    if (typeof mode === "undefined") {
      return this._angleMode;
    } else if (mode === DEGREES || mode === RADIANS) {
      const prevMode = this._angleMode;
      if (mode === prevMode)
        return;
      if (mode === RADIANS) {
        this._setProperty("pRotationX", this.pRotationX * DEG_TO_RAD);
        this._setProperty("pRotationY", this.pRotationY * DEG_TO_RAD);
        this._setProperty("pRotationZ", this.pRotationZ * DEG_TO_RAD);
      } else {
        this._setProperty("pRotationX", this.pRotationX * RAD_TO_DEG);
        this._setProperty("pRotationY", this.pRotationY * RAD_TO_DEG);
        this._setProperty("pRotationZ", this.pRotationZ * RAD_TO_DEG);
      }
      this._angleMode = mode;
    }
  };
  p5.prototype._toRadians = function(angle) {
    if (this._angleMode === DEGREES) {
      return angle * DEG_TO_RAD;
    }
    return angle;
  };
  p5.prototype._toDegrees = function(angle) {
    if (this._angleMode === RADIANS) {
      return angle * RAD_TO_DEG;
    }
    return angle;
  };
  p5.prototype._fromRadians = function(angle) {
    if (this._angleMode === DEGREES) {
      return angle * RAD_TO_DEG;
    }
    return angle;
  };
  p5.prototype._fromDegrees = function(angle) {
    if (this._angleMode === RADIANS) {
      return angle * DEG_TO_RAD;
    }
    return angle;
  };
});

// src/utilities/array_functions.js
var init_array_functions = __esm(() => {
  init_main();
  p5.prototype.shuffle = function(arr, bool) {
    const isView = ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(arr);
    arr = bool || isView ? arr : arr.slice();
    let rnd, tmp, idx = arr.length;
    while (idx > 1) {
      rnd = this.random(0, 1) * idx | 0;
      tmp = arr[--idx];
      arr[idx] = arr[rnd];
      arr[rnd] = tmp;
    }
    return arr;
  };
});

// src/utilities/conversion.js
var init_conversion = __esm(() => {
  init_main();
  p5.prototype.float = function(str) {
    if (str instanceof Array) {
      return str.map(parseFloat);
    }
    return parseFloat(str);
  };
  p5.prototype.int = function(n, radix = 10) {
    if (n === Infinity || n === "Infinity") {
      return Infinity;
    } else if (n === (-Infinity) || n === "-Infinity") {
      return (-Infinity);
    } else if (typeof n === "string") {
      return parseInt(n, radix);
    } else if (typeof n === "number") {
      return n | 0;
    } else if (typeof n === "boolean") {
      return n ? 1 : 0;
    } else if (n instanceof Array) {
      return n.map((n2) => p5.prototype.int(n2, radix));
    }
  };
  p5.prototype.str = function(n) {
    if (n instanceof Array) {
      return n.map(p5.prototype.str);
    } else {
      return String(n);
    }
  };
  p5.prototype.boolean = function(n) {
    if (typeof n === "number") {
      return n !== 0;
    } else if (typeof n === "string") {
      return n.toLowerCase() === "true";
    } else if (typeof n === "boolean") {
      return n;
    } else if (n instanceof Array) {
      return n.map(p5.prototype.boolean);
    }
  };
  p5.prototype.byte = function(n) {
    const nn = p5.prototype.int(n, 10);
    if (typeof nn === "number") {
      return (nn + 128) % 256 - 128;
    } else if (nn instanceof Array) {
      return nn.map(p5.prototype.byte);
    }
  };
  p5.prototype.char = function(n) {
    if (typeof n === "number" && !isNaN(n)) {
      return String.fromCharCode(n);
    } else if (n instanceof Array) {
      return n.map(p5.prototype.char);
    } else if (typeof n === "string") {
      return p5.prototype.char(parseInt(n, 10));
    }
  };
  p5.prototype.unchar = function(n) {
    if (typeof n === "string" && n.length === 1) {
      return n.charCodeAt(0);
    } else if (n instanceof Array) {
      return n.map(p5.prototype.unchar);
    }
  };
  p5.prototype.hex = function(n, digits) {
    digits = digits === undefined || digits === null ? digits = 8 : digits;
    if (n instanceof Array) {
      return n.map((n2) => p5.prototype.hex(n2, digits));
    } else if (n === Infinity || n === (-Infinity)) {
      const c2 = n === Infinity ? "F" : "0";
      return c2.repeat(digits);
    } else if (typeof n === "number") {
      if (n < 0) {
        n = 4294967295 + n + 1;
      }
      let hex = Number(n).toString(16).toUpperCase();
      while (hex.length < digits) {
        hex = `0${hex}`;
      }
      if (hex.length >= digits) {
        hex = hex.substring(hex.length - digits, hex.length);
      }
      return hex;
    }
  };
  p5.prototype.unhex = function(n) {
    if (n instanceof Array) {
      return n.map(p5.prototype.unhex);
    } else {
      return parseInt(`0x${n}`, 16);
    }
  };
});

// src/utilities/string_functions.js
var doNf, doNfc, addNfp, addNfs;
var init_string_functions = __esm(() => {
  init_main();
  doNf = function(num, left, right) {
    let [leftPart, rightPart] = num.toString().split(".");
    if (typeof right === "undefined") {
      leftPart = leftPart.padStart(left, "0");
      return rightPart ? leftPart + "." + rightPart : leftPart;
    } else {
      let roundedOff = num.toFixed(right);
      [leftPart, rightPart] = roundedOff.toString().split(".");
      leftPart = leftPart.padStart(left, "0");
      if (typeof rightPart === "undefined") {
        return leftPart;
      } else {
        return leftPart + "." + rightPart;
      }
    }
  };
  doNfc = function(num, right) {
    num = num.toString();
    const dec = num.indexOf(".");
    let rem = dec !== -1 ? num.substring(dec) : "";
    let n = dec !== -1 ? num.substring(0, dec) : num;
    n = n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    if (right === 0) {
      rem = "";
    } else if (typeof right !== "undefined") {
      if (right > rem.length) {
        rem += dec === -1 ? "." : "";
        const len = right - rem.length + 1;
        for (let i = 0;i < len; i++) {
          rem += "0";
        }
      } else {
        rem = rem.substring(0, right + 1);
      }
    }
    return n + rem;
  };
  addNfp = function(num) {
    return parseFloat(num) > 0 ? `+${num.toString()}` : num.toString();
  };
  addNfs = function(num) {
    return parseFloat(num) >= 0 ? ` ${num.toString()}` : num.toString();
  };
  p5.prototype.join = function(list, separator) {
    return list.join(separator);
  };
  p5.prototype.match = function(str, reg) {
    return str.match(reg);
  };
  p5.prototype.matchAll = function(str, reg) {
    const re = new RegExp(reg, "g");
    let match = re.exec(str);
    const matches = [];
    while (match !== null) {
      matches.push(match);
      match = re.exec(str);
    }
    return matches;
  };
  p5.prototype.nf = function(nums, left, right) {
    if (nums instanceof Array) {
      return nums.map((x) => doNf(x, left, right));
    } else {
      const typeOfFirst = Object.prototype.toString.call(nums);
      if (typeOfFirst === "[object Arguments]") {
        if (nums.length === 3) {
          return this.nf(nums[0], nums[1], nums[2]);
        } else if (nums.length === 2) {
          return this.nf(nums[0], nums[1]);
        } else {
          return this.nf(nums[0]);
        }
      } else {
        return doNf(nums, left, right);
      }
    }
  };
  p5.prototype.nfc = function(num, right) {
    if (num instanceof Array) {
      return num.map((x) => doNfc(x, right));
    } else {
      return doNfc(num, right);
    }
  };
  p5.prototype.nfp = function(...args) {
    const nfRes = p5.prototype.nf.apply(this, args);
    if (nfRes instanceof Array) {
      return nfRes.map(addNfp);
    } else {
      return addNfp(nfRes);
    }
  };
  p5.prototype.nfs = function(...args) {
    const nfRes = p5.prototype.nf.apply(this, args);
    if (nfRes instanceof Array) {
      return nfRes.map(addNfs);
    } else {
      return addNfs(nfRes);
    }
  };
  p5.prototype.split = function(str, delim) {
    return str.split(delim);
  };
  p5.prototype.splitTokens = function(value, delims) {
    let d;
    if (typeof delims !== "undefined") {
      let str = delims;
      const sqc = /\]/g.exec(str);
      let sqo = /\[/g.exec(str);
      if (sqo && sqc) {
        str = str.slice(0, sqc.index) + str.slice(sqc.index + 1);
        sqo = /\[/g.exec(str);
        str = str.slice(0, sqo.index) + str.slice(sqo.index + 1);
        d = new RegExp(`[\\[${str}\\]]`, "g");
      } else if (sqc) {
        str = str.slice(0, sqc.index) + str.slice(sqc.index + 1);
        d = new RegExp(`[${str}\\]]`, "g");
      } else if (sqo) {
        str = str.slice(0, sqo.index) + str.slice(sqo.index + 1);
        d = new RegExp(`[${str}\\[]`, "g");
      } else {
        d = new RegExp(`[${str}]`, "g");
      }
    } else {
      d = /\s/g;
    }
    return value.split(d).filter((n) => n);
  };
  p5.prototype.trim = function(str) {
    if (str instanceof Array) {
      return str.map(this.trim);
    } else {
      return str.trim();
    }
  };
});

// src/utilities/time_date.js
var init_time_date = __esm(() => {
  init_main();
  p5.prototype.day = function() {
    return new Date().getDate();
  };
  p5.prototype.hour = function() {
    return new Date().getHours();
  };
  p5.prototype.minute = function() {
    return new Date().getMinutes();
  };
  p5.prototype.millis = function() {
    if (this._millisStart === -1) {
      return 0;
    } else {
      return window.performance.now() - this._millisStart;
    }
  };
  p5.prototype.month = function() {
    return new Date().getMonth() + 1;
  };
  p5.prototype.second = function() {
    return new Date().getSeconds();
  };
  p5.prototype.year = function() {
    return new Date().getFullYear();
  };
});

// src/index.js
var require_src = __commonJS((exports, module) => {
  init_main();
  init_constants();
  init_color_conversion();
  init_p5_Color();
  init_creating_reading();
  init_calculation();
  init_math();
  init_noise();
  init_p5_Vector();
  init_random();
  init_trigonometry();
  init_array_functions();
  init_conversion();
  init_string_functions();
  init_time_date();
  module.exports = p5;
});
export default require_src();
